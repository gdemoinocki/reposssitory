#include "list.h"

// Функция для создания нового элемента списка
item_t *list_create(int val) {
    // Выделяем память под новый элемент списка
    item_t *new_item = (item_t *)malloc(sizeof(item_t));
    if (!new_item) {
        // Если память не удалось выделить, возвращаем NULL
        return NULL;
    }

    // Инициализируем данные элемента
    new_item->data = val;
    // Инициализируем указатель на следующий элемент как NULL
    INIT_LIST_HEAD(&(new_item->lists));

    // Возвращаем указатель на созданный элемент
    return new_item;
}

// Функция для добавления нового элемента в конец списка
void list_append(item_t *head, int val) {
    // Создаем новый элемент с заданным значением
    item_t *new_item = list_create(val);
    if (!new_item) {
        // Если не удалось создать элемент, завершаем функцию
        return;
    }

    // Добавляем новый элемент в конец списка
    list_add_tail(&(new_item->lists), &(head->lists));
}

// Функция для уничтожения списка и освобождения памяти
void list_destroy(item_t *head) {
    // Если список пуст, завершаем функцию
    if (head == NULL) {
        return;
    }

    // Указатели для прохода по списку
    struct list_head *current = head->lists.next;
    struct list_head *temp;

    // Проходим по всем элементам списка
    while (current != NULL) {
        // Сохраняем указатель на следующий элемент
        temp = current->next;
        // Получаем указатель на текущий элемент списка
        item_t *item = list_entry(current, item_t, lists);
        // Освобождаем память, выделенную под текущий элемент
        free(item);
        // Переходим к следующему элементу
        current = temp;
    }

    // Освобождаем память, выделенную под головной элемент
    free(head);
}

// Функция для вычисления длины списка
size_t list_length(item_t *head) {
    // Если список пуст, возвращаем 0
    if (head == NULL) {
        return 0;
    }

    // Начинаем с 1, так как головной элемент уже есть
    size_t count = 1;

    // Указатель для прохода по списку
    item_t *pos;
    // Проходим по всем элементам списка, начиная с головного
    list_for_each_entry(pos, &(head->lists), lists) {
        count++;
    }

    // Возвращаем количество элементов в списке
    return count;
}

// Функция для проверки наличия значения
